package vulnerabilities;

import dev.aikido.agent_api.background.Endpoint;
import dev.aikido.agent_api.context.ContextObject;
import dev.aikido.agent_api.thread_cache.ThreadCache;
import dev.aikido.agent_api.thread_cache.ThreadCacheObject;
import dev.aikido.agent_api.vulnerabilities.SkipVulnerabilityScanDecider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import utils.EmptySampleContextObject;
import utils.EmtpyThreadCacheObject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class SkipVulnerabilityScanDeciderTest {

    private ContextObject context;
    private ThreadCacheObject threadCacheObject;
    private List<Endpoint> createEndpoints(boolean protectionForcedOff1, boolean protectionForcedOff2) {
        List<Endpoint> endpoints = new ArrayList<>();
        endpoints.add(new Endpoint("POST", "/api/login", 3, 1000, Collections.emptyList(), false, protectionForcedOff1, true));
        endpoints.add(new Endpoint("POST", "/api/*", 1, 1000, Collections.emptyList(), false, protectionForcedOff2, true));
        endpoints.add(new Endpoint("GET", "/", 3, 1000, Collections.emptyList(), false, false, false));
        return endpoints;
    }
    private List<Endpoint> createEndpointsWildcardMethod(boolean protectionForcedOff1, boolean protectionForcedOff2) {
        List<Endpoint> endpoints = new ArrayList<>();
        endpoints.add(new Endpoint("*", "/api/login", 3, 1000, Collections.emptyList(), false, protectionForcedOff1, true));
        endpoints.add(new Endpoint("*", "/api/*", 1, 1000, Collections.emptyList(), false, protectionForcedOff2, true));
        endpoints.add(new Endpoint("GET", "/", 3, 1000, Collections.emptyList(), false, false, false));
        return endpoints;
    }

    @BeforeEach
    public void setUp() {
        context = new EmptySampleContextObject();
        threadCacheObject = EmtpyThreadCacheObject.getEmptyThreadCacheObject();
        // Mock the ThreadCache to return our empty thread cache object
        ThreadCache.set(threadCacheObject);
    }

    @Test
    public void testShouldSkipVulnerabilityScan_NullContext() {
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(null));
    }

    @Test
    public void testShouldSkipVulnerabilityScan_ProtectionForcedOff_1() {
        // Mock the ThreadCacheObject to return a matched endpoint
        ThreadCacheObject mockThreadCache = mock(ThreadCacheObject.class);
        when(mockThreadCache.getEndpoints()).thenReturn(createEndpoints(true, false));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "GET")
        ));

        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login2", "POST")
        ));

        when(mockThreadCache.getEndpoints()).thenReturn(createEndpoints(false, false));
        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));
    }

    @Test
    public void testShouldSkipVulnerabilityScan_ProtectionForcedOff_1_WildCard() {
        // Mock the ThreadCacheObject to return a matched endpoint
        ThreadCacheObject mockThreadCache = mock(ThreadCacheObject.class);
        when(mockThreadCache.getEndpoints()).thenReturn(createEndpointsWildcardMethod(true, false));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login2", "POST")
        ));

        when(mockThreadCache.getEndpoints()).thenReturn(createEndpointsWildcardMethod(false, false));
        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));
    }

    @Test
    public void testShouldSkipVulnerabilityScan_ProtectionForcedOff_2() {
        // Mock the ThreadCacheObject to return a matched endpoint
        ThreadCacheObject mockThreadCache = mock(ThreadCacheObject.class);
        when(mockThreadCache.getEndpoints()).thenReturn(createEndpoints(false, true));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "GET")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login2", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/", "POST")
        ));

        when(mockThreadCache.getEndpoints()).thenReturn(createEndpoints(true, true));
        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "GET")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login2", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/", "POST")
        ));
    }

    @Test
    public void testShouldSkipVulnerabilityScan_ProtectionForcedOff_WildcardMethod() {
        // Mock the ThreadCacheObject to return a matched endpoint
        ThreadCacheObject mockThreadCache = mock(ThreadCacheObject.class);
        when(mockThreadCache.getEndpoints()).thenReturn(createEndpointsWildcardMethod(false, true));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login2", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/", "POST")
        ));

        when(mockThreadCache.getEndpoints()).thenReturn(createEndpointsWildcardMethod(true, true));
        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login2", "POST")
        ));

        ThreadCache.set(mockThreadCache);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/", "POST")
        ));
    }

    @Test
    public void testShouldSkipVulnerabilityScan_NoConditionsMet() {

        // Create a mocked endpoint with protection not forced off
        Endpoint endpoint = mock(Endpoint.class);
        when(endpoint.protectionForcedOff()).thenReturn(false);

        // Mock the ThreadCacheObject to return a matched endpoint
        ThreadCacheObject mockThreadCache = mock(ThreadCacheObject.class);
        when(mockThreadCache.getEndpoints()).thenReturn(createEndpoints(false, false));
        when(mockThreadCache.isBypassedIP(context.getRemoteAddress())).thenReturn(false);
        ThreadCache.set(mockThreadCache);

        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(
                new EmptySampleContextObject("", "/api/login", "POST")
        ));
    }

    @Test
    public void testUsesCache() {
        ContextObject ctx = new EmptySampleContextObject("", "/api/login", "POST");
        assertTrue(ctx.getForcedProtectionOff().isEmpty());

        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(ctx));
        assertTrue(ctx.getForcedProtectionOff().isPresent());
        assertFalse(ctx.getForcedProtectionOff().get());

        assertFalse(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(ctx));

        ctx.setForcedProtectionOff(true);
        assertTrue(SkipVulnerabilityScanDecider.shouldSkipVulnerabilityScan(ctx));
    }
}
