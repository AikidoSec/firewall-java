package dev.aikido.agent_api.vulnerabilities;

import dev.aikido.agent_api.background.Endpoint;
import dev.aikido.agent_api.context.ContextObject;
import dev.aikido.agent_api.thread_cache.ThreadCache;
import dev.aikido.agent_api.thread_cache.ThreadCacheObject;

import java.util.List;

import static dev.aikido.agent_api.helpers.patterns.MatchEndpoints.matchEndpoints;

public final class SkipVulnerabilityScanDecider {
    private SkipVulnerabilityScanDecider() {}
    public static boolean shouldSkipVulnerabilityScan(ContextObject context) {
        if (context == null) {
            return true;
        }
        if (context.getForcedProtectionOff().isEmpty()) {
            // cache value not present, go fetch
            ThreadCacheObject threadCache = ThreadCache.get(/* shouldFetch: */ false);
            if (threadCache == null) {
                return false; // thread cache not defined, unable to loop
            }

            List<Endpoint> matchedEndpoints = matchEndpoints(context.getRouteMetadata(), threadCache.getEndpoints());
            if (matchedEndpoints != null && matchedEndpoints.stream().anyMatch(Endpoint::protectionForcedOff)) {
                // Protection is forced off on one of more of the matched endpoints :
                context.setForcedProtectionOff(true);
            } else {
                context.setForcedProtectionOff(false);
            }
        }

        // Get stored forcedProtectionOff value from cache.
        return context.getForcedProtectionOff().get();
    }
}
